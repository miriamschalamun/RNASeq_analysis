---
title: "RNASeq_analysis"
author: "Miriam Schalamun"
date: "15 11 2023"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r libraries}
library("DESeq2")
library(stringr)
library(readxl)
library(ggplot2)
library(dplyr)
library(ggrepel)
library(apeglm)
library("pheatmap")
library("RColorBrewer")
library("genefilter")
library(gplots)
library(tidyverse) 
library(edgeR) 
library(matrixStats)
library("matchmaker")
library("xlsx")
library(dendextend)
library(topGO)
library(rrvgo)
```

```{r set up working directory and date}

setwd("/path/to/script")

today <- Sys.Date()
today <- format(today, format = "%y%m%d", trim_ws = T)

#load annotation file - Modified from "The Genomes of Three Uneven Siblings: Footprints of the Lifestyles of Three Trichoderma Species"  Schmoll et al. 2016 
annotation <- read_excel("/path/to//Annotation_file.xlsx")

```

```{r sest up directories and functions}
# This creates all the directories needed later on, dont need to change but execute each time

directory <- function(name){
  if (file.exists(name)) {
    cat("the folder already exists")
  }    else {
    dir.create(name)
  }
}

directory("contrasts")
directory("contrasts/all")
directory("contrasts/significant")
directory("contrasts/strong_filtering")
directory("plots")
directory("plots/PCA")
directory("plots/clust")
directory("plots/MA")
directory("plots/heatmaps")
directory("annotation")
directory("normalized")

# General function that are used multiple times and I call upon below, if you want to change something then here and check (with Strg F where this functions else are used)

PCA_plot <- function(data, name, postfix){
  png(filename = paste0("plots/PCA/", name,"_PCA_", postfix, "_", today, ".png"), width = 1600, height = 900, res = 300)
  pcaData <- plotPCA(data, intgroup="strain", returnData=TRUE) 
  percentVar <- round(100 * attr(pcaData, "percentVar"))
  print(ggplot(pcaData, aes(PC1, PC2, color=strain, label=rownames(pcaData))) + 
          geom_point() +
          geom_text_repel(size=2) +
          xlab(paste0("PC1: ",percentVar[1],"% variance")) +
          ylab(paste0("PC2: ",percentVar[2],"% variance")) + 
          coord_fixed())
  dev.off()
}

clust_plot <- function(data, name, plot){
  png(filename = paste0("plots/clust/", name, "_", plot, "_", today, ".png"), width = 1600, height = 1600, res = 300)
  plot(data)
  dev.off()
}

MA_plot <- function(data, name){
  png(filename = paste0("plots/MA/", name, today, "_MA.png"), width = 1600, height = 900, res = 300)
  DESeq2::plotMA(data, ylim=c(-3,3), cex=.3, alpha = 0.05)
  abline(h=c(-1,1), col="dodgerblue", lwd=2)
  dev.off()
}

LFC_padj_function <- function(data, name){
  data_padj <- subset(data, padj < 0.05)
  data_LFC1 <- subset(data_padj, log2FoldChange < -1 | log2FoldChange > 1)
  data_significant <- data_LFC1[order(data_LFC1$log2FoldChange),]
}

clean_contrast_function <- function(dds, mutant, WT, light1, light2){
  dds2$strain <- relevel(dds2$strain, paste0(WT, "_", light1))
  dds2 <- nbinomWaldTest(dds2)
  coef <- paste0("strain_", mutant, "_", light2, "_vs_", WT, "_", light1)
  res_shrunk <- lfcShrink(dds2, coef = coef, type = "apeglm")
}  

#this is the function behind the "annotation" basically just automatically feeding the contrasts into the anno file 

annotation_function <- function(data, name){
  as.data.frame(annotation)
  as.data.frame(annotation)
  as.data.frame(data)
  
  colnames(data) <- c("gene", "basemean", "log2FoldChange", "lfcSE", "pvalue", "padj")
  data <- data[,c("gene", "log2FoldChange")]
  
  foldchange <- gtools::logratio2foldchange(data$log2FoldChange)
  as.matrix(foldchange)
  contrast_fold <- data.frame(data, foldchange)
  
  upregulated <- subset(contrast_fold, log2FoldChange > 1)
  up_anno <- right_join(annotation, upregulated, by = c("Geneid" = "gene"))
  up_anno <- up_anno %>% relocate(log2FoldChange, foldchange, .after = `position in chromosome`)
  up_anno <- up_anno[order(up_anno$log2FoldChange, decreasing = T),]
  up_anno <- as.data.frame(up_anno)
  
  downregulated <- subset(contrast_fold, log2FoldChange < -1)
  down_anno <- right_join(annotation, downregulated, by = c("Geneid" = "gene"))
  down_anno <- down_anno %>% relocate(log2FoldChange, foldchange, .after = `position in chromosome`)
  down_anno <- down_anno[order(down_anno$log2FoldChange),]
  down_anno <- as.data.frame(down_anno)
  
  write.xlsx(up_anno, file = paste0(name), sheetName = paste0("up"), row.names = F, append = T)
  write.xlsx(down_anno, file = paste0(name), sheetName = paste0("down"), row.names = F, append = T)
  
}

heatmap_plot <- function(data, name, postfix, rownumbers){
  avvsd_topic <- tibble::rownames_to_column(data, "gene")
  anno_topic <- annotation[,c("Geneid", "MMBR gene name", "TOPIC", "MMBR group", "Anno Trichoderma topic")]
  topic <- right_join(anno_topic, avvsd_topic, by = c("Geneid" = "gene"))
  topic <- as.data.frame(topic)
  topic <- column_to_rownames(topic, var = "Geneid")
  
  row_anno <- as.data.frame(topic$`TOPIC`)
  rownames(row_anno) <- paste(row.names(topic))
  colnames(row_anno)<- c("Function")
  
  col_anno <- data.frame(condition = ifelse(grepl("LL",colnames(topic)), "Light", "Dark"))
  row.names(col_anno) <- colnames(topic)

  #standard heatmap without any focus on topic
  
  topVar <- head(order(-rowVars(data)), n=rownumbers)
  mat <- data[topVar, ]
  mat <- mat - rowMeans(mat)
  png(filename = paste0("plots/heatmaps/", name, "_heatmap_", rownumbers, "_", postfix, "_", today, ".png"), width = 1600, height = 1600, res = 300)
  pheatmap(mat, color=colorRampPalette(c("blue", "white", "red"))(50), show_rownames = F, cutree_cols = 1, cutree_rows = 1, fontsize_row = 4, fontsize = 6, treeheight_row = 40, treeheight_col = 20, annotation_row = row_anno, annotation_col = col_anno)
  dev.off()
}


heatmap_plot_TOPIC <- function(data, name, postfix, rownumbers, whichTOPIC){
  
avvsd_topic <- tibble::rownames_to_column(data, "gene")
  anno_topic <- annotation[,c("Geneid", "MMBR gene name", "TOPIC", "MMBR group", "Anno Trichoderma topic")]
  topic <- right_join(anno_topic, avvsd_topic, by = c("Geneid" = "gene"))
  topic <- as.data.frame(topic)
  topic <- column_to_rownames(topic, var = "Geneid")
  
  col_anno <- data.frame(condition = ifelse(grepl("LL",colnames(topic)), "Light", "Dark"))
  row.names(col_anno) <- colnames(topic)

  whichTOPIC <- whichTOPIC
topic_filtered <- filter(topic, TOPIC == whichTOPIC)
print(whichTOPIC)

# takes the column MMBR group for row annotation (= the groups for eg function)
# first create a "clean names" table

row_anno <- as.data.frame(topic_filtered$`MMBR group`)
rownames(row_anno) <- paste(row.names(topic_filtered))
colnames(row_anno)<- c("Function")

# column annotations (DD or LL mostly)
col_anno <- data.frame(condition = ifelse(grepl("LL",colnames(topic_filtered)), "Light", "Dark"))
row.names(col_anno) <- colnames(topic_filtered)

# subset columns = samples (eg if more datasets combined or you only want DD or LL and to only have the normalized counts (it doesnt work if there are the descriptions in there ,therefore you always have to call for all the samples you want in the heatmap))

topic_heatmap <- as.data.frame(topic_filtered[, !(colnames(topic_filtered) %in% c("MMBR gene name", "TOPIC", "MMBR group", "Anno Trichoderma topic"))])

 topVar <- head(order(-rowVars(topic_heatmap)), n=rownumbers)
  mat <- topic_heatmap[topVar, ]
  mat <- mat - rowMeans(mat)
  
  png(filename = paste0("plots/heatmaps/", name, "_heatmap_", rownumbers, "_", postfix, "_", whichTOPIC, "_", today, ".png"), width = 1600, height = 1600, res = 300)
  pheatmap(mat, color=colorRampPalette(c("blue", "white", "red"))(50), show_rownames = F, cutree_cols = 1, cutree_rows = 1, fontsize_row = 4, fontsize = 6, treeheight_row = 40, treeheight_col = 20, annotation_row = row_anno, annotation_col = col_anno, main = whichTOPIC)
  dev.off()
}

```

```{r count and meta file and compute DEseq2 for single dataset }
####################################CHANGE#################################
# here change the name to the "dataset" you are working with (eg Gproteins), this is then displayed in file names and load the count and meta file (needed by DESeq2)

ds_name <- "example_data"

# read count table from featurecounts 
cts <- read.table("featurecounts_example.txt", header=TRUE, row.names = 1, check.names = F)

# rename every but the first (length) column by extracting only the NGS ids
colnames(cts)[-1] <- str_extract(colnames(cts)[-1], '[0-9]+')

# Add meta file 
meta <- read_excel("meta_example.xlsx", col_names = TRUE)

#cts_new <- rename_with(colnames(cts), row.names(meta))


##############################################################################

# from here on everything stays the same in this section

meta$strain <- factor(meta$strain)
meta$light <-factor(meta$lightregime)
sample_names <- meta$replicate
meta$replicate <- factor(meta$replicate)
rownames(meta) <- meta$replicate

# check if rownames of metatable fit to colnames of counttable MUST BE "TRUE" if not there is a mistake eg sample missing and order must correspond! 

all(meta$NGS_ID %in% colnames(cts)[-1])
all(colnames(cts)[-1] == meta$NGS_ID)

# ONLY PERFORM sample renaming (from NGSS_ID to sample name) if the above is TRUE - if not than samples are swiched!! 


if (all(colnames(cts)[-1] == meta$NGS_ID)){
  colnames(cts)[-1] <- c(sample_names) 
} else {
  print("sample names don't correspond to NGS IDs")
}

# creaets a count file with renamed sample names corresponding to the names provided in the meta file
write.csv2(cts, paste0("renamed_counts_", ds_name, "_", today, ".csv"))    

# here the "dds" is computed, which allows for contrasts and comparison of samples for more detail refer to the DESeq2 Vignette

dds <- DESeq2::DESeqDataSetFromMatrix(countData = cts[-1],
                                      colData = meta,
                                      design = ~ strain)
mcols(dds)$basepairs <- cts$Length

dds <- DESeq(dds, minReplicatesForReplace=Inf)
dds2 <- dds # is needed for stronger filtering in contrasts


```

```{r #vst normalization}
#vst noralized counts (a function of DESeq2 for variance stabilization transformation, these are used for PCA and heatplots)

vsd <- vst(dds, blind = F)
colnames(vsd) <- paste(vsd$replicate)
write.csv2(assay(vsd), paste0("normalized/vsd_normalized_", ds_name, "_", today, ".csv" ))

# calculate average vsd (from the 3 replicates) before applying the formula I have to create the matrix with correct number of rows and columns and then the formula (for(i...) does the trick)

unique <- unique(as.matrix(vsd$strain))
avvsd <- matrix(0, NROW(vsd), ncol = NROW(unique))
rownames(avvsd) <- rownames(vsd)
colnames(avvsd) <- c(unique)
avvsd <- as.data.frame(avvsd) 

for(i in unique(vsd$strain)){
  avvsd[[i]] <- c(rowMeans(assay(vsd) [, vsd$strain == i]))
}


#subset LL and DD
vsd_DD <- vsd[ , vsd$light %in% c("DD")]

vsd_LL <- vsd[ , vsd$light %in% c("LL")]

# for DD
unique <- unique(as.matrix(vsd_DD$strain))
avvsd_DD <- matrix(0, NROW(vsd_DD), ncol = NROW(unique))
rownames(avvsd_DD) <- rownames(vsd_DD)
colnames(avvsd_DD) <- c(unique)
avvsd_DD <- as.data.frame(avvsd_DD) 

for(i in unique(vsd_DD$strain)){
  avvsd_DD[[i]] <- c(rowMeans(assay(vsd_DD) [, vsd_DD$strain == i]))
}


# for LL

unique <- unique(as.matrix(vsd_LL$strain))
avvsd_LL <- matrix(0, NROW(vsd_LL), ncol = NROW(unique))
rownames(avvsd_LL) <- rownames(vsd_LL)
colnames(avvsd_LL) <- c(unique)
avvsd_LL <- as.data.frame(avvsd_LL) 

for(i in unique(vsd_LL$strain)){
  avvsd_LL[[i]] <- c(rowMeans(assay(vsd_LL) [, vsd_LL$strain == i]))
}

```

```{r PCA }
# this executes the PCA plot function and outputs the plots in the directory plots/PCA/
PCA_plot(data = vsd, name = ds_name, postfix = "")
PCA_plot(data = vsd_DD, name = ds_name, postfix = "DD")
PCA_plot(data = vsd_LL, name = ds_name, postfix = "LL")

```

```{r heatmap }
# this creates heatmaps usin pheatmap in the plots/heatmaps directory, the functions are at the top of the script if you want to change settings (eg. if you want to show gene names or or the color)

# enter the number of how many genes should be displayed, e.g. 100
rownumbers <- 100

#the postfix adds whatever you want in the title description e.g. test (write within the "")

heatmap_plot(data = avvsd, name = ds_name, rownumbers = 100, postfix = "test")

heatmap_plot(data = avvsd_DD, name = ds_name, rownumbers = 100, postfix = "DD")

heatmap_plot(data = avvsd_LL, name = ds_name, rownumbers = 100, postfix = "LL")


########################
# if you want to look at a specific topic: 
#example topics: Secondary metabolism, CAZymes, Transcription factors, Transporters..the spelling has to be exactly like in the annotation_file

# the rownumbers might be lower than for above because some topics only have a few genes in them (eg there are ~400 CAZymes in total of which only a few might show different expression levels, so it likely is more interesting to only look at a subset of the most regulated ones, eg. 50 )

rownumbers <- 80 
whichTOPIC <- "Transcription factors"

heatmap_plot_TOPIC(data = avvsd, name = ds_name, rownumbers, postfix = "", whichTOPIC)

heatmap_plot_TOPIC(data = avvsd_DD, name = ds_name, rownumbers, postfix = "DD", whichTOPIC)
heatmap_plot_TOPIC(data = avvsd_LL, name = ds_name, rownumbers, postfix = "LL", whichTOPIC)

# filter by "TOPIC" and the type you want to filter for (eg Secondary metabolism or CAZymes, must be written exactly as in the annotation file) 

```

```{r clustering of samples with hclust }
#clustering of samples with hclust
dist <- dist(t(avvsd), method = "euclidean")
hc <- hclust(dist, method = "complete")
plot(hc)
clust_plot(data = hc, name = ds_name, plot = "clust_")

```

```{r contrasts}
####################################CHANGE#################################
# Create the which_contrasts file with the headers "WT" and "mutant" and then enter which contransts you want to have 

# This outputs 2 different files in the contrasts directory: "all" contrasts contain all genes, "sig" contrasts contain filtered for padj and log2fold change, you can change these values below. The naming of files is in a way that the last name in the file name is the "base" to which the contrasts was done, so usually the WT (or in the light vs dark ones, DD is the base)  


contrasts <- as.data.frame(read_excel("which_contrasts.xlsx"))

for(i in 1:nrow(contrasts)){
  WT <- contrasts$WT[i]
  mutant <- contrasts$mutant[i]
  contrast_name <- paste0(mutant, "__", WT)

  name <- paste0("contrasts/all/", contrast_name,"_all_", today, ".csv")
  name_sig <- paste0("contrasts/significant/", contrast_name,"_sig_", today, ".csv")

#Contrasts: 
  if (file.exists(name_sig)) {
      cat("the file already exists")
  }else{
    
    res <- results(dds, contrast=c("strain", mutant, WT), cooksCutoff = F, independentFiltering = F)
    data_padj <- subset(res, padj < 0.05)
    data_LFC1 <- subset(data_padj, log2FoldChange < -1 | log2FoldChange > 1)
    data_significant <- data_LFC1[order(data_LFC1$log2FoldChange),]
    write.csv2(res, name)
    write.csv2(data_significant, name_sig)
    MA_plot(data = res, name = contrast_name)
    MA_plot(data = data_significant, name = contrast_name)
  }
}

#note: cookscutoff = F because it sets padj to NA (for more info see vignette)
# independentfiltering = F because it automatically removes low count genes and I want to see them first before deciding to remove them

# Also MA plots are created here and can be found in /plots/MA. With those you can compare the number of counts with the log fold change for a contrast. Meaning that a regulated gene that eg has 10 vs 3 counts (towards the left side of the graph) is likely not as "important" as a gene that has eg 10000 vs 300 counts. The grey dots are the insignificant (p adj > 0.05) and blue are significant (p adj < 0.05). everything between the light blue line we consider as not significant as well because the log2 fold change is between -1 and 1. 

```

```{r stronger filtered contrasts (LFCShrinkage)}
# if there are many (> 1000 genes significantly regulated you could consider applying a stricter filterig using the LFC_shrink function from DESeq2 package to remove outlier and low count genes 
# These can be found in the /contrasts/stronger_filtering directory 

# LFC shrinkage using apeglm from Zhu et al 2018  
for(i in 1:nrow(contrasts)){
  WT <- contrasts$WT[i]
  mutant <- contrasts$mutant[i]
  contrast_name <- paste0(mutant, "__", WT)
  name_shrinkage <- paste0("contrasts/strong_filtering/", contrast_name,"_shrinkage_", today, ".csv")
#Contrasts: 
  if (file.exists(name_shrinkage)) {
      cat("the file already exists")
  }else{
    dds2$strain <- relevel(dds2$strain, paste0(WT))
    dds2 <- nbinomWaldTest(dds2)
    coef <- paste0("strain_", mutant, "_vs_", WT)
    res_shrunk <- lfcShrink(dds2, coef = coef, type = "apeglm")
    shrunk_padj <- subset(res_shrunk, padj < 0.05)
    shrunk_LFC1 <- subset(shrunk_padj, log2FoldChange < -1 | log2FoldChange > 1)
    shrunk_significant <- shrunk_LFC1[order(shrunk_LFC1$log2FoldChange),]
    write.csv2(shrunk_significant, name_shrinkage)

  }
}

```

```{r Automatic annotation file}
# annotation file already loaded at top of script
# if you change the LFC threshold change it in the annotation_function at the top of the script (so either eg 1, or 0.58 )
#This uses the "significant" contrasts created above, you can change that by changeing the path location 
#This can take a few minutes and files are found in annotation directory 


contrast_files <- dir(path = "contrasts/significant/", pattern = ".csv", full.names = T, recursive = F)
for(i in contrast_files){
  data <- read.csv2(i)
  anno_name <- tools::file_path_sans_ext(base::basename(i))
  name <- paste0("annotation/", anno_name, "_anno", ".xlsx")
  
  if (file.exists(name)) {
      cat("the file already exists")
  }else
    annotation_function(data = data, name = name)
}

```

```{r CPM count normalization}
# These can also be used for visualizations like PCA and heatmaps
# CPM using voom 
voom.design <- model.matrix(~0 + meta$strain)
colnames(voom.design) <- levels(meta$strain)
eset <- voom(cts[-1], voom.design)
colnames(eset) <- meta$replicate

which(!is.finite(eset$E))  
head(eset$E)   # log2-counts per million (logCPM)log2(0.5)

write.csv2(as.data.frame(geneID = rownames(eset$E), eset$E), paste("normalized/logCPM_", ds_name, today, ".csv"),row.names = T)

##linear model fitting (ANOVA)
fitFPKM <- lmFit(eset, voom.design)  

write.csv2(as.data.frame(geneID = rownames(fitFPKM$coefficients), fitFPKM$coefficients), paste("normalized/logCPM_avg_", ds_name, today, ".csv"), row.names = T)

```

```{r FPKM count normalization}
# These can also be used for visualizations like PCA and heatmaps
# calculates FPKM (Fragments Per Kilobase of transcript per Million mapped reads) values using DESeq2 
fpkm <- fpkm(dds, robust = T)
head(fpkm)
colnames(fpkm) <- paste(vsd$replicate)
write.csv2(fpkm, paste0("normalized/fpkm", "_",ds_name, "_", today, "_", ".csv"))

```

```{r GO&rrvgo Functions}
# creates the directories and functions for GO enrichment and visualization, here you don't need to change anything. Just execute.

directory <- function(name){
  if (file.exists(name)) {
    cat("the folder already exists")
  }    else {
    dir.create(name)
  }
}
directory("GO")
directory("GO/rrvgo")
directory("GO/plots")
directory("GO/plots/treemap")
directory("GO/plots/treemap/BP")
directory("GO/plots/treemap/BP/weighted")
directory("GO/plots/treemap/BP/classic")
directory("GO/plots/treemap/MF")
directory("GO/plots/treemap/MF/weighted")
directory("GO/plots/treemap/MF/classic")

Gofunction <- function(data, name, rrvgo, ontology){
  
  as.data.frame(data)
  data <- as.character(data[,c(1)])
  geneList2 <- factor(as.integer(geneUniverse %in% data))
  names(geneList2) <- geneUniverse

# build the GOdata object, use BP (biol. proc.); MF (molec. func.) or CC (cel. comp.)
  GOdata <- new("topGOdata", ontology = category, allGenes = geneList2,  annot = annFUN.gene2GO, gene2GO = geneID2GO)

# Cacluate p-value using the fisher's exact test 
  resultClassic <- runTest(GOdata, algorithm="classic", statistic ="fisher")
  
  resultweight01 <- runTest(GOdata, algorithm="weight01", statistic = "fisher")
  
  allRes <- GenTable(GOdata, classicFisher = resultClassic, weighted = resultweight01, orderBy = "classicFisher", ranksOf = "classicFisher", topNodes = length(topGO::score(resultClassic)))
  
  cutoff <- subset(allRes, classicFisher < 1)
  write.csv2(allRes, name, row.names = F)
  write.csv2(allRes[,c("GO.ID", "classicFisher", "weighted")], rrvgo, row.names = F)
}


rrvgo_function_MF_classic <- function(data, name, pvalue, threshold){
  go_analysis <- data
  go_analysis$classicFisher <- (as.numeric(go_analysis$classicFisher))
  go_analysis_p <- subset(go_analysis, classicFisher < pvalue)
  
  simMatrix <- rrvgo::calculateSimMatrix(go_analysis_p$GO.ID, ont = "MF", method = "Rel", orgdb = "org.Sc.sgd.db")
  
  scores <- setNames(-log10(go_analysis$classicFisher), go_analysis$GO.ID)
  
  reducedTerms <- reduceSimMatrix(simMatrix, scores, threshold, orgdb = "org.Sc.sgd.db")
  
  png(filename = paste0("GO/plots/treemap/MF/classic/", name, "_p", pvalue, "_", threshold, ".png"), width = 1600, height = 1600, res = 300)
rrvgo::treemapPlot(reducedTerms = reducedTerms)

dev.off()
}

rrvgo_function_MF_weighted <- function(data, name, pvalue, threshold){
  go_analysis <- data
  go_analysis$weighted <- (as.numeric(go_analysis$weighted))
  go_analysis_p <- subset(go_analysis, weighted < pvalue)
  
  simMatrix <- rrvgo::calculateSimMatrix(go_analysis_p$GO.ID, ont = "MF", method = "Rel", orgdb = "org.Sc.sgd.db")
  
  scores <- setNames(-log10(go_analysis$weighted), go_analysis$GO.ID)
  
  reducedTerms <- reduceSimMatrix(simMatrix, scores, threshold, orgdb = "org.Sc.sgd.db")
  
  png(filename = paste0("GO/plots/treemap/MF/weighted/", name, "_p", pvalue, "_", threshold, "_weighted", ".png"), width = 1600, height = 1600, res = 300)
rrvgo::treemapPlot(reducedTerms = reducedTerms)

dev.off()
}

rrvgo_function_BP_classic <- function(data, name, pvalue, threshold){
  go_analysis <- data
  go_analysis$classicFisher <- (as.numeric(go_analysis$classicFisher))
  go_analysis_p <- subset(go_analysis, classicFisher < pvalue)
 
  
  simMatrix <- rrvgo::calculateSimMatrix(go_analysis_p$GO.ID, ont = "BP", method = "Rel", orgdb = "org.Sc.sgd.db")
  
  scores <- setNames(-log10(go_analysis$classicFisher), go_analysis$GO.ID)
  
  reducedTerms <- reduceSimMatrix(simMatrix, scores, threshold, orgdb = "org.Sc.sgd.db")
   
  filename <- paste0("GO/plots/treemap/BP/classic/", name, "_p", pvalue, "_", threshold, ".png")
  print(filename)
  if (file.exists(filename)) {
    cat("the file already exists")
  }else
  png(filename = filename,  width = 1600, height = 1600, res = 300)
rrvgo::treemapPlot(reducedTerms = reducedTerms)

dev.off()
}

 
rrvgo_function_BP_weighted <- function(data, name, pvalue, threshold){
  go_analysis <- data
  go_analysis$weighted <- (as.numeric(go_analysis$weighted))
  go_analysis_p <- subset(go_analysis, weighted < pvalue)
  
  simMatrix <- rrvgo::calculateSimMatrix(go_analysis_p$GO.ID, ont = "BP", method = "Rel", orgdb = "org.Sc.sgd.db")
  
  scores <- setNames(-log10(go_analysis$weighted), go_analysis$GO.ID)
  
  reducedTerms <- reduceSimMatrix(simMatrix, scores, threshold, orgdb = "org.Sc.sgd.db")
 
  filename <- paste0("GO/plots/treemap/BP/weighted/", name, "_p", pvalue, "_", threshold, ".png")
  print(filename)
  if (file.exists(filename)) {
    cat("the file already exists")
  }else
  png(filename = filename,  width = 1600, height = 1600, res = 300)
rrvgo::treemapPlot(reducedTerms = reducedTerms)

dev.off()
}


scatterplot_function_BP_classic <- function(data, name, pvalue, threshold){
  go_analysis <- data
  go_analysis$classicFisher <- (as.numeric(go_analysis$classicFisher))
  go_analysis_p <- subset(go_analysis, classicFisher < pvalue)
  
  simMatrix <- rrvgo::calculateSimMatrix(go_analysis_p$GO.ID, ont = "BP", method = "Rel", orgdb = "org.Sc.sgd.db")
  
  scores <- setNames(-log10(go_analysis$classicFisher), go_analysis$GO.ID)
  
  reducedTerms <- reduceSimMatrix(simMatrix, scores, threshold, orgdb = "org.Sc.sgd.db")
  
  png(filename = paste0("GO/plots/scatterplot/BP/", "scatter_", name, "_p", pvalue, "_", threshold, ".png"), width = 1600, height = 1600, res = 300)
rrvgo::scatterPlot(simMatrix, reducedTerms, size = "score")

dev.off()
}

```

```{r topGo GO enrichment}
# Performs GO enrichment using topGO 

BPterms <- ls(GOBPTerm)
MFterms <- ls(GOMFTerm)

# Load custom annotation file  
geneID2GO <- readMappings(file = "C:/Users/SchalamunM/OneDrive - AIT/Analysis/Github/GOterms.txt")


# I needed in a format that I have one gene ID and listed next to it the GO terms
GO2geneID <- inverseList(geneID2GO) 
geneID2GO <- inverseList(GO2geneID)
str(head(geneID2GO))

# set names of all genes that we have for the GOterms 
geneNames <- names(geneID2GO)
geneUniverse <- names(geneID2GO)

# automatically loads all significant contrasts and performs the Gofunction - might take a few minutes, so this means in this cas you perform the go enrichment only on the significantly differntially regulated genes

contrast_files <- dir(path = "contrasts/significant/", full.names = T, recursive = F)

######### Here you can change which category you want BP (biological process) or MF (molecular function)
category <- "MF"

for(i in contrast_files){
  data <- read.csv2(i)
  GO_name <- tools::file_path_sans_ext(base::basename(i))
  ontology <- category
  name <- paste0("GO/","GO_", GO_name, "_", ontology, ".csv")
  rrvgo <- paste0("GO/rrvgo/","rrvgo_", GO_name, ontology, ".csv")
  if (file.exists(name)) {
      cat("the file already exists ")
  }else

Gofunction(data = data, name = name, rrvgo=rrvgo, ontology = category)
}

# run the tests to determine pvalues for each go term using different algorithms. classic: "each GO term is tested independently not taking the GO hierachy into account. weight01:a mix between "weight" and "elim" - is more conservative than classic but has less false positives and might miss  true positives but the significance of scores (Alexa et al 2006 - Improved scoring of functional groups...).  However in many publications classic fisher is used. The advantage of weighted is that to me it sounds its more reliable and in the later created trees for visualization you more likely get the parent terms which make it easier to find important terms than looking at >100 terms 

```

```{r Visualize GO enrichment using rrvgo}
# Visualize using rrvgo and the yeast database for the names
# yeast db: 
library("org.Sc.sgd.db")

####### Biological Process category (BP)
# loads the files (path) from GO enrichment that are prepared so that rrvgo can use them
rrvgo_files_BP <- dir(path = "GO/rrvgo", pattern = "BP.csv", full.names = T, recursive = F)

# you can change these values and see how the graphs change and can be found in: GO/plots/treemap/
# takes a few minutes 
threshold <- "0.7"# between 0.1 and 1 
pvalue <- "0.1"

# classic algortithm
for(i in rrvgo_files_BP){
  data <- read.csv2(i)
  GO_name <- tools::file_path_sans_ext(base::basename(i))
  name <- paste0(GO_name)
  threshold <- paste0(threshold)
  pvalue <- paste0(pvalue)
rrvgo_function_BP_classic(data, name, pvalue, threshold)
}

#weighted algorithm (more stringent but might loose info)
for(i in rrvgo_files_BP){
  data <- read.csv2(i)
  GO_name <- tools::file_path_sans_ext(base::basename(i))
  name <- paste0(GO_name)
  threshold <- paste0(threshold)
  pvalue <- paste0(pvalue)

rrvgo_function_BP_weighted(data, name, pvalue, threshold)
}


######### Molecular Function category (MF) 
rrvgo_files_MF <- dir(path = "GO/rrvgo/", pattern = "MF.csv", full.names = T, recursive = F)

for(i in rrvgo_files_MF){
  data <- read.csv2(i)
  GO_name <- tools::file_path_sans_ext(base::basename(i))
  name <- paste0(GO_name)
  threshold <- paste0(threshold)
  pvalue <- paste0(pvalue)

rrvgo_function_MF_classic(data, name, pvalue, threshold)
}

```
